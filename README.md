# Краткая справка

**Оговорюсь что одна СУБД (Postgres) содержит внутри все необходимые базы данных и таблицы.**
> Задание тестовое, хотелось сделать акцент на чистом коде и успеть всё в срок. Прошу не вычитывать баллы за некорректное с точки зрения `production-ready`-подхода распределение сущностей в Базе Данных.

## Навигация

- **`service/`** - папка с исходным кодом
- **`migrations/`** - папка с миграциями к БД

---

- [Make](#make)
- [Миграция](#миграция)
- [Решения проблем](#решения-проблем)

## Make

**! ВСЕ КОМАНДЫ ЗАПУСКАТЬ В `root` ДИРЕКТОРИИ (там же где лежит [Makefile](Makefile))**

- `make run` - _автоматический запуск без сборки бинарника_
- `make build` **(локальная сборка)** - _сбора бинарника с автоматическим определением **ОС** и **Архитектуры**_
- `make build-linux-amd64` - _запуск с `GOOS=linux` и `GOARCH=amd64` соответственно_
- `make build-darwin-arm64` - _запуск с `GOOS=darwin` и `GOARCH=arm64` соответственно_
- `make build-windows` - _запуск с `GOOS=windows` и `GOARCH=amd64` соответственно_

## ENV

> _Переменные окружения уже предъобявлены (**`ALL.env`**) для быстрой проверки работоспособности и избавления от рутины `reviewer`-а. Но для проверяющих которым недостадочно кода - ниже все переменные окружения._  

- **`DSN`** - путь к базе данных
- **`ADMIN_TOKEN`** - токен который используется в заголовках некоторых запросов, но желателен находиться во всех

## Решения Проблем

**При углублении в ТЗ переданный командой Avito я выявил несколько проблем:**

### 1. Проблема уникальности идентификаторов в глобальной области  

Присваивание самим автором идентификаторов `user_id` нецелесообразно по причинам:

- Если команда N и команда M присвоят одинаковые идентификаторы (например: `u1`), то идентификатор пользователя автоматически становится неуникальным на уровне приложения. Положиться на удачу? С каждой новой командой в приложении, шанс на дубликат увеличивается с каждым пользователем в одной команде.

**Мое решение:**

> В `POST /users/setIsActive` нужно положить ещё одно поле: `team_name`, а также в `GET /users/getReview` нужно добавить **+ 1 query var**: `team_name`.  
> Так я не сломал логику `/team/add` хендлера где поля `members.user_id` создаёт лишь проблему. А составные идентификаторы (`members.user_id`) в свою очередь, реализуют уникальность на уровне команды. А глобально база данных сама выдает уникальный идентификатор каждому `user`.
